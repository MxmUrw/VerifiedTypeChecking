
{-# OPTIONS --cubical --allow-unsolved-metas --no-import-sorts #-}

module Verification.Core.Category.Instance.SetProperties where

open import Verification.Conventions
open import Verification.Core.Category.Definition
open import Verification.Core.Category.Functor
open import Verification.Core.Category.Adjunction
open import Verification.Core.Category.KanLimit.Definition2
-- open import Verification.Core.Category.Limit.Definition
-- open import Verification.Core.Category.Limit.Product
-- open import Verification.Core.Category.Limit.Equalizer
-- open import Verification.Core.Category.Monad
open import Verification.Core.Category.Instance.Type
open import Verification.Core.Category.Instance.Cat
open import Verification.Core.Category.FreeCategory
open import Verification.Core.Category.Quiver
open import Verification.Core.Category.Instance.Set.Definition
open import Verification.Core.Category.Lift
open import Verification.Core.Homotopy.Level


--------------------------------------------------------------------
-- Equalizers

data Pair : ùí∞‚ÇÄ where
  ‚ÇÄ ‚ÇÅ : Pair


data PairHom : Pair -> Pair -> ùí∞‚ÇÄ where
  arr‚ÇÄ : PairHom ‚ÇÄ ‚ÇÅ
  arr‚ÇÅ : PairHom ‚ÇÄ ‚ÇÅ

Quiver:Pair : Quiver (many ‚Ñì‚ÇÄ)
‚ü® Quiver:Pair ‚ü© = Pair
IQuiver.Edge (of Quiver:Pair) = PairHom
-- IQuiver.Edge (of Quiver:Pair) ‚ÇÄ ‚ÇÄ = ‚ä•
-- IQuiver.Edge (of Quiver:Pair) ‚ÇÄ ‚ÇÅ = ùüö-ùí∞
-- IQuiver.Edge (of Quiver:Pair) ‚ÇÅ b = ‚ä•
IQuiver._‚âà_ (of Quiver:Pair) = _‚â°_
IQuiver.IEquivInst (of Quiver:Pair) = IEquiv:Path

Category:Pair = Category:Free (Quiver:Pair)

instance
  ICategory:Pair = of Category:Pair

-- instance
--   Index-Notation:Diagram : ‚àÄ{S : Quiver (‚Ñì‚ÇÄ , ‚Ñì‚ÇÄ , ‚Ñì‚ÇÄ)} {X : Category ùëñ} -> Index-Notation ((‚Üë Category:Free S) ‚ü∂ X)
--                                                                                            (‚ü® S ‚ü© √ó-ùí∞ ‚ü® S ‚ü©)
--                                                                                            (IAnything)
--                                                                                            (Œª (D , (a , b)) -> Edge {{of S}} a b -> Hom (‚ü® D ‚ü© (lift a)) (‚ü® D ‚ü© (lift b)))
--   (Index-Notation:Diagram Index-Notation.‚åÑ D) (a , b) e = map (lift (some (last e)))


record _=?=-Set_ {A : Set ùëñ} {B : Set ùëó} (f g : HTypeHom A B) : ùí∞ (ùëñ ÔΩ§ ùëó) where
  constructor _,_
  field fst : ‚ü® A ‚ü©
        snd : ‚ü® f ‚ü© fst ‚â° ‚ü® g ‚ü© fst
        -- {{Set:B}} : IHType 2 ‚ü® B ‚ü©
open _=?=-Set_ public

-- _S,_ : {A : Set ùëñ} {B : Set ùëó} {f g : HTypeHom A B} -> (a : ‚ü® A ‚ü©) -> (p : ‚ü® f ‚ü© a ‚â° ‚ü® g ‚ü© a) -> f =?=-Set g
-- _S,_ {B = B} a p = _,_ a p {{of B}}

_Set:=?=-Set_ : {A : Set ùëñ} {B : Set ùëó} -> (f g : HTypeHom A B) -> Set (ùëñ ÔΩ§ ùëó)
‚ü® f Set:=?=-Set g ‚ü© = f =?=-Set g
of (f Set:=?=-Set g) = {!!}


-- _=?=-Set_ : {A : Set ùëñ} {B : Set ùëó} -> (f g : HTypeHom A B) -> Set (ùëñ ÔΩ§ ùëó)
-- ‚ü® f =?=-Set g ‚ü© = ‚àë Œª a -> ‚ü® f ‚ü© a ‚â° ‚ü® g ‚ü© a
-- IHType.hlevel (of (_=?=-Set_  {A = A} {B} f g)) = isOfHLevelŒ£ 2 (hlevel {{of A}}) (Œª x -> isOfHLevelSuc 1 (hlevel {{of B}} _ _))


byFirst1 : {A : Set ùëñ} {B : Set ùëó} -> {f g : HTypeHom A B} -> {a b : f =?=-Set g} -> fst a ‚â° fst b -> a ‚â° b
byFirst1 {A = A}{B}{f}{g}{a}{b} p i = p i , isSet‚ÜíisSet' (hlevel {{of B}}) (snd a) (snd b) (cong ‚ü® f ‚ü© (p)) (cong ‚ü® g ‚ü© (p)) i

-- instance
--   Cast:SigmaEq : ‚àÄ{ùëñ ùëó : ùîè} {A : Set ùëñ} {B : Set ùëó} -> {f g : HTypeHom A B} -> {a b : f =?=-Set g} -> Cast (fst a ‚â° fst b) IAnything (a ‚â° b)
--   Cast.cast Cast:SigmaEq p = byFirst1 p


-- {‚ü® f ‚ü© (fst a)} {‚ü® g ‚ü© (fst a)} {‚ü® f ‚ü© (fst b)} {‚ü® g ‚ü© (fst b)} ? ? ? ? i
-- byFirst1 {A = A}{B}{f}{g}{a}{b} p i = p i , isSet‚ÜíisSet' (hlevel {{of B}}) {‚ü® f ‚ü© (fst a)} {‚ü® g ‚ü© (fst a)} {‚ü® f ‚ü© (fst b)} {‚ü® g ‚ü© (fst b)} ? ? ? ? i

-- byFirst0 : {A : Set ùëñ} {B : Set ùëó} -> {f g : HTypeHom A B} -> {a : ‚ü® A ‚ü©} -> {b1 b2 : ‚ü® f ‚ü© a ‚â° ‚ü® g ‚ü© a} -> PathP (Œª i -> f =?=-Set g) (a , b1) (a , b2)
-- byFirst0 {B = B} {f} {g} {a} {b1} {b2} i = _ , hlevel {{of B}} _ _ b1 b2 i
-- byFirst1 p = {!!}


-- instance
--   setinstance : ‚àÄ{A : ùí∞ ùëñ} -> {F : A -> Set ùëó} -> ‚àÄ{a : A} -> ISet (‚ü® F a ‚ü©)
--   setinstance {F = F} {a = a} = of (F a)

byfirst : ‚àÄ{A : ùí∞ ùëñ} {B : A -> ùí∞ ùëó} -> ‚àÄ{a1 : A} -> {b1 : B a1} {b2 : B a1} -> (isOfHLevel 1 (B a1)) -> PathP (Œª i -> ‚àë Œª (a : A) -> B a) (a1 , b1) (a1 , b2)
byfirst {b1 = b1} {b2} lev i = _ , lev b1 b2 i



byfirst2 : ‚àÄ{A : ùí∞ ùëñ} {B : A -> ùí∞ ùëó} -> ‚àÄ{a1 : A} -> {b1 : B a1} {b2 : B a1} -> {{_ : IHType 1 (B a1)}} -> PathP (Œª i -> ‚àë Œª (a : A) -> B a) (a1 , b1) (a1 , b2)
byfirst2 {b1 = b1} {b2} {{lev}} i = _ , (hlevel {{lev}}) b1 b2 i

-- testttt = cong2

funExtSet : ‚àÄ{A : Set ùëñ} {B : Set ùëó} -> {f g : HTypeHom A B} -> (‚àÄ(a : ‚ü® A ‚ü©) -> {{_ : IHType 2 ‚ü® B ‚ü©}} -> ‚ü® f ‚ü© a ‚â° ‚ü® g ‚ü© a) -> HTypeHomEq f g
‚ü® funExtSet p ‚ü© = Œª i x -> p x i
of funExtSet p = record {}

-- explicitArgs : ‚àÄ{A : ùí∞ ùëñ} {B : ùí∞ ùëó} {C : ùí∞ ùëô} {D : ùí∞ ùëò} -> (f : )

module _ where
  private
    L : Functor (‚©ö (‚Üë Category:Pair ‚ü∂ ‚©ö Set ùëñ)) (‚©ö (ùüô ‚ü∂ ‚©ö Set ùëñ))
    ‚ü® L {ùëñ} ‚ü© F = free-Diagram-Lift f
      where f : QuiverHom (‚©ö ‚ä§) (ForgetCategory (‚©ö Set _))
            ‚ü® f ‚ü© _ = ((map {{of F}} (‚Ü• ` arr‚ÇÄ `)) Set:=?=-Set (map {{of F}} (‚Ü• ` arr‚ÇÅ `)))
              -- where instance _ = of (‚ü® F ‚ü© (‚Ü• ‚ÇÄ))
              --                _ = of (‚ü® F ‚ü© (‚Ü• ‚ÇÅ))
            -- ‚àë Œª (x : ‚ü® ‚ü® F ‚ü© (‚Ü• ‚ÇÄ) ‚ü©) -> (F ‚åÑ (‚ÇÄ , ‚ÇÅ)) ‚ÇÄ x ‚â° (F ‚åÑ (‚ÇÄ , ‚ÇÅ)) ‚ÇÅ x
            IQuiverHom.qmap (of f) e = ‚åò Œª x -> x
    IFunctor.map (of L) Œ± = free-Diagram-Nat f (Œª {()})
      where f = Œª {_ -> ‚åò Œª {(x , xp) -> ‚ü® ‚ü® Œ± ‚ü© ‚ü© x , let P : ‚ü® (‚ü® Œ± ‚ü© ‚óÜ map _) ‚ü© x ‚â° ‚ü® (‚ü® Œ± ‚ü© ‚óÜ map _) ‚ü© x
                                                           P = ((naturality _ x)) ‚àô cong ‚ü® ‚ü® Œ± ‚ü© ‚ü© xp ‚àô ( (naturality _ x ‚Åª¬π))
                                                           -- P = (cong (Œª Œæ -> Œæ $ x) (naturality _ x)) ‚àô cong ‚ü® ‚ü® Œ± ‚ü© ‚ü© xp ‚àô (cong (Œª Œæ -> Œæ $ x) (naturality _ ‚Åª¬π))
                                                        in P}}
      -- where f = Œª {_ (x , xp) -> ‚ü® Œ± ‚ü© x , let P : ‚ü® Œ± ‚ü© ‚óÜ map _ ‚â° ‚ü® Œ± ‚ü© ‚óÜ map _
      --                                          P = naturality _ ‚àô {!!}
      --                                      in cong (_$ x) P}
    IFunctor.functoriality-id (of L) {a = a} Œ± _ = byFirst1 refl --funExt (Œª _ -> byFirst1 refl)
    -- funExt (Œª {(x , xp) -> byfirst (targethlevel {{of (map Œ±)}} _ _) }) -- {{of ‚ü® a ‚ü© (‚Ü• ‚ÇÅ)}}
    -- x , hlevel {{of ‚ü® a ‚ü© (‚Ü• ‚ÇÅ)}} _ _ _ _ i}) -- ({!!} , {!!})
    IFunctor.functoriality-‚óÜ (of L) {a = a} {b} {c} x _ = byFirst1 refl -- funExt (Œª _ -> byFirst1 refl) -- funExt (Œª _ -> byfirst (hlevel {{of ‚ü® c ‚ü© (‚Ü• ‚ÇÅ)}} _ _))
    IFunctor.functoriality-‚â£ (of L) p _ x = byFirst1 (p _ (fst x))


    ùí´ : ‚àÄ{ùëñ} -> Category ùëñ
    ùí´ = ‚Üë Category:Pair

    -- FG = Functor:comp-Cat L (! ùí´ *)


    Œµ : ‚àÄ(x : (ùí´) ‚ü∂ ` Set ùëñ `) -> ‚àÄ(a : Pair)
        -> (‚ü® ‚ü® ! ùí´ * ‚ü© (‚ü® L ‚ü© x) ‚ü© (‚Ü• a)) ‚ü∂ ‚ü® x ‚ü© (‚Ü• a)
    Œµ x ‚ÇÄ = ‚åò Œª (a , p) -> a
    Œµ x ‚ÇÅ = ‚åò Œª (a , p) -> ‚ü® map {{of x}} (` arr‚ÇÄ `) ‚ü© a -- ((x ‚åÑ (‚ÇÄ , ‚ÇÅ)) ‚ÇÄ)‚ü© a

    Œµp : ‚àÄ{ùëñ} -> ‚àÄ(x : ùí´ ‚ü∂ (‚©ö Set ùëñ)) -> ‚àÄ{a b : Pair} -> (e : Edge {{of Quiver:Pair}} a b)
        -> Œµ x a ‚óÜ map (` e `) ‚â£ map {{of (‚ü® ! ùí´ * ‚ü© (‚ü® L ‚ü© x))}} {a = ‚Ü• a} {b = ‚Ü• b} (` e `) ‚óÜ Œµ x b
        -- (‚ü® ‚ü® ! (‚Üë Category:Pair) * ‚ü© (‚ü® L ‚ü© x) ‚ü© (‚Ü• a)) ‚ü∂ ‚ü® x ‚ü© (‚Ü• a)
    Œµp x {‚ÇÄ} {‚ÇÅ} arr‚ÇÄ _ = refl
    Œµp x {‚ÇÄ} {‚ÇÅ} arr‚ÇÅ (y , yp) =  let -- P : ? fst (‚ü® map {{of x}} (‚Ü• ` ‚ÇÅ `) ‚ü© (y , yp)) ‚â° ?
                                      P : (‚ü® map {{of x}} (` arr‚ÇÅ `) ‚ü© y) ‚â° (‚ü® map {{of x}} (` arr‚ÇÄ `) ‚ü© y)
                                      P = yp ‚Åª¬π
                                  in P

    Œµ' : ‚àÄ(x : ùí´ ‚ü∂ ` Set ùëñ `) -> Natural (‚ü® ! ùí´ * ‚ü© (‚ü® L ‚ü© x)) x
    Œµ' x = free-Diagram-Nat (Œµ x) (Œµp x)

    -- Œµ2 : ‚àÄ{ùëñ : ùîè} -> ‚àÄ{a b : Pair}
    --     -> ‚àÄ(g : Edge a b) -> ‚àÄ(x : (‚Üë Category:Pair) ‚ü∂ (Category:Set ùëñ)) -> ‚ä§ -- ‚àÄ(e : ) -- (‚ü® ‚ü® ! (‚Üë Category:Pair) * ‚ü© (‚ü® L ‚ü© x) ‚ü© (‚Ü• a)) ‚ü∂ ‚ü® x ‚ü© (‚Ü• a)
    -- Œµ2 = {!!}

    Œ∑ : ‚àÄ(x : ùüô ‚ü∂ ` Set ùëñ `) -> ‚àÄ(a : ‚ä§)
        -> ‚ü® x ‚ü© (‚Ü• a) ‚ü∂ (‚ü® ‚ü® L ‚ü© (‚ü® ! ùí´ * ‚ü© x) ‚ü© (‚Ü• a))
    Œ∑ _ = Œª _ -> ‚åò Œª {a -> (a , refl)}

    Œ∑' : ‚àÄ(x : ùüô ‚ü∂ ` Set ùëñ `) -> Natural x (‚ü® L ‚ü© (‚ü® ! ùí´ * ‚ü© x))
    Œ∑' x = free-Diagram-Nat (Œ∑ x) (Œª {()})


    lem::1 : (! (‚Üë Category:Pair) *) ‚ä£ L {ùëñ = ùëñ}
    ‚ü® IAdjoint.embed lem::1 ‚ü© {x = x} = Œ∑' x -- free-Diagram-Nat (Œ∑ x) 
      -- where f = Œª _ -> ‚åò Œª {a -> (a , refl)}
      --       fp = Œª {()}
    INatural.naturality (of IAdjoint.embed lem::1) f x _ = byFirst1 refl -- funExt (Œª {_ -> byFirst1 refl})
    ‚ü® IAdjoint.eval lem::1 ‚ü© {x = x} = Œµ' x
    -- free-Diagram-Nat (Œµ x) (Œµp x) -- (Œµp x) --  (Œª {{a = ‚ÇÄ} {b = ‚ÇÅ} ‚ÇÄ -> {!!};
    --                                                           {‚ÇÄ} {‚ÇÅ} ‚ÇÅ -> ?})
    --   where f = Œª {‚ÇÄ -> (‚åò Œª {(a , p) -> a});
    --                ‚ÇÅ -> (‚åò Œª {(a , p) -> ‚ü®((x ‚åÑ (‚ÇÄ , ‚ÇÅ)) ‚ÇÄ)‚ü© a})}
            -- fp = ?
    INatural.naturality (of IAdjoint.eval lem::1) Œ± (‚Ü• ‚ÇÄ) _ = refl -- funExt (Œª {_ -> byFirst1 refl})
    INatural.naturality (of IAdjoint.eval lem::1) {x = a} {b} Œ± (‚Ü• ‚ÇÅ) (x , xp) =
                           let P : ‚ü® ‚ü® Œ± ‚ü© ‚ü© (‚ü® map {{of a}} (` arr‚ÇÄ `) ‚ü© x) ‚â° ‚ü® map {{of b}} (` arr‚ÇÄ `) ‚ü© (‚ü® ‚ü® Œ± ‚ü© ‚ü© x)
                               P = naturality {{of Œ±}} (` arr‚ÇÄ `) x ‚Åª¬π
                            in P
    IAdjoint.reduce-Adj-Œ≤ lem::1 (‚Ü• ‚ÇÄ) _ = refl
    IAdjoint.reduce-Adj-Œ≤ lem::1 {a = a} (‚Ü• ‚ÇÅ) x = functoriality-id {{of a}} x
    IAdjoint.reduce-Adj-Œ∑ lem::1 (‚Ü• tt) _ = byFirst1 refl -- funExt (Œª _ -> byFirst1 refl)


-- Evaluating reduce-Œ≤ by hand...
-- even though agda can show it...
      -- let -- P : ‚ü® (map {{of ! ùí´ *}} (Œ∑' a) ‚óÜ Œµ' (‚ü® ! ùí´ * ‚ü© a)) ‚ü© {‚Ü• ‚ÇÅ} ‚â£ id
      --     -- P = {!!}
      --     -- Q : ‚ü® map {{of ! ùí´ *}} (Œ∑' a) ‚ü© {‚Ü• ‚ÇÅ} ‚óÜ ‚ü® Œµ' (‚ü® ! ùí´ * ‚ü© a) ‚ü© {‚Ü• ‚ÇÅ} ‚â£ id
      --     -- Q = {!!}

      --     -- Q' : ‚ü® ‚ü® map {{of ! ùí´ *}} (Œ∑' a) ‚ü© {‚Ü• ‚ÇÅ} ‚óÜ ‚ü® Œµ' (‚ü® ! ùí´ * ‚ü© a) ‚ü© {‚Ü• ‚ÇÅ} ‚ü© ‚â° id {{of Category:ùí∞ _}}
      --     -- Q' = {!!}

      --     -- Q'' : ‚ü® ‚ü® map {{of ! ùí´ *}} (Œ∑' a) ‚ü© {‚Ü• ‚ÇÅ} ‚ü© ‚óÜ ‚ü® ‚ü® Œµ' (‚ü® ! ùí´ * ‚ü© a) ‚ü© {‚Ü• ‚ÇÅ} ‚ü© ‚â° id {{of Category:ùí∞ _}}
      --     -- Q'' = {!!}

      --     -- Q''' : ‚àÄ x -> ‚ü® ‚ü® Œµ' (‚ü® ! ùí´ * ‚ü© a) ‚ü© {‚Ü• ‚ÇÅ} ‚ü© (‚ü® ‚ü® map {{of ! ùí´ *}} (Œ∑' a) ‚ü© {‚Ü• ‚ÇÅ} ‚ü© x) ‚â° x
      --     -- Q''' = {!!}

      --     -- Q'''' : ‚àÄ x -> ‚ü® map {{of (‚ü® ! ùí´ * ‚ü© a)}} ` arr‚ÇÄ ` ‚ü© (fst (‚ü® ‚ü® map {{of ! ùí´ *}} (Œ∑' a) ‚ü© {‚Ü• ‚ÇÅ} ‚ü© x)) ‚â° x
      --     -- Q'''' = {!!}

      --     -- Q''''' : ‚àÄ x -> ‚ü® map {{of (‚ü® ! ùí´ * ‚ü© a)}} ` arr‚ÇÄ ` ‚ü© (fst (‚ü® ‚ü® Œ∑' a ‚ü© { ‚ü® (! ùí´) ‚ü© (‚Ü• ‚ÇÅ)} ‚ü© x)) ‚â° x
      --     -- Q''''' = {!!}

      --     -- Q'''''' : ‚àÄ x -> ‚ü® map {{of (‚ü® ! ùí´ * ‚ü© a)}} ` arr‚ÇÄ ` ‚ü© (fst (‚ü® ‚ü® Œ∑' a ‚ü© { (‚Ü• tt)} ‚ü© x)) ‚â° x
      --     -- Q'''''' = {!!}

      --     -- Q''''''' : ‚àÄ x -> ‚ü® map {{of (! ùí´ ‚óá a)}} ` arr‚ÇÄ ` ‚ü© (x) ‚â° x
      --     -- Q''''''' = {!!}

      --     -- Q'''''''' : ‚àÄ x -> ‚ü® map {{of a}} (map {{of ! ùí´}} ` arr‚ÇÄ `) ‚ü© (x) ‚â° x
      --     -- Q'''''''' = {!!}

      --     -- Q''''''''' : ‚àÄ x -> ‚ü® map {{of a}} (id {{of ùüô}}) ‚ü© (x) ‚â° x
      --     -- Q''''''''' = {!!}
      --     aa : ‚Ñï
      --     aa = 1

      -- in functoriality-id {{of a}}



